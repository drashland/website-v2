# Main Commands

## Table of Contents

- [About Main Commands](#about-main-commands)
  - [Example Main Command](#example-main-command)
- [Caveats](#caveats)
  - [Differentiating Signatures](#differentiating-signatures)
    - [Option 1: Provide Explicit Installation Instructions](#option-1-provide-explicit-installation-instructions)
    - [Option 2: Use a Generic Signature](#option-2-use-a-generic-signature)
- [Configuration](#configuration)
  - [Signatures](#signatures)
  - [Arguments](#arguments)
  - [Options](#options)
  - [Subcommands](#subcommands)
  - [The Handler Method](#the-handler-method)

## About Main Commands

All Line CLIs must have a main command. The main command is Line's entry point
to your code. All main commands must extend the `Line.MainCommand` class. This
is the base class for all main commands. You can define your own base main
command class, but it _MUST_ extend the `Line.MainCommand` class for type
checking and to inherit required data members.

There can only be one main command in a Line CLI. This is true for both
[single command CLIs](/line/v1.x/tutorials/creating-a-cli/single-command-clis/introduction#about-single-command-clis)
and
[subcommand CLIs](/line/v1.x/tutorials/creating-a-cli/subcommand-clis/introduction#about-subcommand-clis).

Under the hood, the `Line.MainCommand` class extends `Line.Command` class.

### Example Main Command

To create a main command class, extend the `Line.MainCommand` class and provide
a `signature`:

```typescript
// main_command.ts

import { Line } from "./deps.ts";

export class SomeMainCommandClass extends Line.MainCommand {
  public signature = "greet";
}
```

In the above, `greet` is specified as the main command. This means you expect
users to use `greet` as the main command to your CLI.

This page will not go over the all of the implementation details of a main
command because it can vary greatly depending on things like adding arguments,
adding options, and adding subcommands. However, there are tutorials in the
sidebar that go over creating the following CLIs so that you get a better sense
of how to create your main command's implementation:

- [Creating a CLI > Single Command CLIs](/line/v1.x/tutorials/creating-a-cli/single-command-clis/introduction)
- [Creating a CLI > Subcommand CLIs](/line/v1.x/tutorials/creating-a-cli/subcommand-clis/introduction)

## Caveats

### Differentiating Signatures

Based on
[Deno's documentation on script installations](https://deno.land/manual/tools/script_installer),
Line has no control over what users will use as an executable's name. Even
though you can specify an explicit `signature` in a main command class, users
can still specify `--name some-random-name` when installing your CLI and they
will be able to use `some-random-name` as the main command instead of what you
specified in your main command's `signature`. This can cause great confusion.

For example, say you have a `GreetMainCommand` with a `signature` of ...

```typescript
public signature = "greet";
```

... and you installed your CLI using `--name greet` ...

```shell
$ deno install --name greet cli.ts
```

Doing the above will allow you to run `greet` and you will be shown the
following help menu (automatically generated by Line):

```text
$ greet

Greeter CLI - A CLI that outputs greetings

USAGE

    greet [option]

OPTIONS

    -h, --help
        Show this menu.
    -v, --version
        Show this CLI's version.
```

This help menu makes sense because the `USAGE` section shows `greet`, but what
if a user installs your CLI using `--name` like so:

```shell
$ deno install --name tester app.ts
```

The user would be able to run your CLI using `tester` instead of `greet` and
when they are shown your CLI's help menu, they will see the following `USAGE`
section:

```text
USAGE

    greet [option]
```

As you can see, the `USAGE` section still shows `greet`. This is because of the
following:

- You defined a `signature` of `greet`
- The user installed your CLI using a different name than what is specified by
  you
- Line only knows about _YOUR_ CLI's signature, so it uses that in the help
  menu(s)

Below are two options to help you prevent this confusion:

#### Option 1: Provide Explicit Installation Instructions

This first option comes from
[Deno's documentation on script installations](https://deno.land/manual/tools/script_installer)
and we recommend it.

You can provide explicit installation instructions to your users. That is, give
them something like the following:

> When installing this CLI, please use the following command:
>
> ```shell
> $ deno install --name greet app.ts.
> ```
>
> If you install this CLI using a different `--name`, then please be aware that
> the help menu(s) will not reflect the `--name` you have chosen.

#### Option 2: Use a Generic Signature

Another option is to use a placeholder in your main command's signature. For
example:

```typescript
class GreetMainCommand extends Line.MainCommand {
  public signature = "<COMMAND>";
}
```

When users install your CLI with the above main command and are shown the help
menu, they will see the following in the `USAGE` section:

```text
USAGE

    <COMMAND> [option]
```

This way, users can be free to install your CLI as they please and will see a
generic `<COMMAND>` instead of something you defined. However, it would be best
to tell users that `<COMMAND>` is a placeholder for the `--name` they used when
installing your CLI. For example, you can provide users with the following:

> The help menu(s) in this CLI contain `<COMMAND>` in the USAGE section(s).
> Please be aware that this is just a placeholder value for help menu purposes.
> This command is actually the command you specified with the `--name` option
> when installing this CLI.

Also take note that this approach may cause ambiguity to some users beacuse
`<COMMAND>` can mean anything at first glance.

## Configuration

### Signatures

To add/modify a main command's signature, add/modify its `signature` property:

```typescript
import { Line } from "./deps.ts";

class MyMainCommand extends Line.MainCommand {
  public signature = "greet";
  // or public signature = "test";
  // or public signature = "yarn";

  ...
  ...
  ...
}
```

### Arguments

To add/modify a main command's arguments, add/modify its `signature` property:

```typescript
import { Line } from "./deps.ts";

class MyMainCommand extends Line.MainCommand {
  public signature = "greet [some_arg]";
  // or public signature = "greet [some_arg]";
  // or public signature = "greet [some_other_arg_name] [some_second_arg]";

  ...
  ...
  ...
}
```

If your main command takes arguments, it must have a `handle()` method in order
to handle them:

```typescript
import { Line } from "./deps.ts";

class MyMainCommand extends Line.MainCommand {
  ...
  ...
  ...

  public handle(): void { // can also be async
    console.log(this.argument("the_argument_name"));
  }

  ...
  ...
  ...
}
```

To learn more about using arguments, read
[Arguments > Introduction](/line/v1.x/tutorials/arguments/introduction) and its
respective tutorials (under "Arguments" in the side bar).

#### Argument Descriptions

To add descriptions to your arguments, follow the steps outlined on the
[Arguments > Argument Descriptions](/line/v1.x/tutorials/arguments/argument-descriptions)
page.

### Options

To add/modify a main command's options, add/modify its `options` property:

```typescript
import { Line } from "./deps.ts";

class MyMainCommand extends Line.MainCommand {
  ...
  ...
  ...

  public options = {
    "--some-option": "Some description for the option.",
    // or "-s, --some-option": "Some description for the option.",
    // or "-s [value], --some-option [value]": "Some description for the option.",
  }

  ...
  ...
  ...
}
```

If your main command takes options, it must have a `handle()` method in order to
handle them:

```typescript
import { Line } from "./deps.ts";

class MyMainCommand extends Line.MainCommand {
  ...
  ...
  ...

  public handle(): void { // can also be async
    console.log(this.option("--some-option"));
  }

  ...
  ...
  ...
}
```

To learn more about using options, read
[Options > Introduction](/line/v1.x/tutorials/options/introduction) and its
respective tutorials (under "Options" in the side bar).

### Subcommands

To add/modify subcommands a main command's subcommands, add/modify its
`subcommands` property:

```typescript
import { Line } from "./deps.ts";
import { SomeSubcommand } from "./some_subcommand.ts";

class MyMainCommand extends Line.MainCommand {
  ...
  ...
  ...

  public subcommands = [
    SomeSubcommand,
  ];

  ...
  ...
  ...
}
```

To learn more about using subcommands, read the following:

- [Commands > Subcommands](/line/v1.x/tutorials/commands/subcommands)
- [Creating a CLI > Subcommand CLIs](/line/v1.x/tutorials/creating-a-cli/subcommand-clis/introduction)

### The Handler Method

To add/modify a main command's handler method, edit its `handle()` method.

The `handle()` method is the method Line calls under the hood to execute the
main command. This method is in charge of processing your main command's code.
An example of a `handle()` could be as simple as ...

```typescript
public handle(): void { // or public async handle(): Promise<void> {
  console.log("Hello!");
}
```

... or as complex as ...

```typescript
public async handle(): Promise<void> {
  console.log("Process started");

  const response = await fetch("http://something.tld");

  // ... handle the response
  // ... take the contents of the response and write it to a file
  // ... send the file to your private server
  // ... verify the above operation
  // ... output log messages on the status

  console.log("Process finished");
}
```
