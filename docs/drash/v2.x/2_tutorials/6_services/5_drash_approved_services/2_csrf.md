# CSRF

This service is a [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
protection service inspired by
[expressjs/csurf](http://expressjs.com/en/resources/middleware/csurf.html). It
can be simply placed as a middleware for your resources and you are all set!

Simply add it to your resources that require CSRF protection and you are all set!

## Table of Contents

- [Before You Get Started](#before-you-get-started)
- [Folder Structure End State](#folder-structure-end-state)
- [Steps](#configuration)
- [Verification](#verification)
- [How It Works](#how-it-works)

## Before You Get Started

To use this service, edit your `deps.ts` file to include the service.

```typescript
// deps.ts

...
...
...
export { CSRFService } from "https://deno.land/drash@<VERSION>/services.ts";
```

Replace `<VERSION>` with the Drash version you want to use. All versions can be found [here](https://github.com/drashland/drash/releases).

## Folder Structure End State

```text
â–¾ /path/to/your/project/
  app.ts
  deps.ts
```

## Steps

1. Create your `app.ts` file.

```typescript
// app.ts

import {
  Drash,
  CSRFService,
} from "./deps.ts";

// Instantiate the service and generate the token. The token can be accessed
// via `csrf.token`.
const csrf = new CSRFService();

// Create your resource

class HomeResource extends Drash.Resource {

  public paths = ["/"];

  // Tell the resource what HTTP methods should have CSRF protection. In this
  // case, we are telling the resource to protect the POST method. This means
  // the POST method will require the CSRF token.
  public services = {
    POST: [ csrf ],
  };

  public GET(request: Drash.Request, response: Drash.Response): void {
    // Set the token on the response headers
    response.headers.set("X-CSRF-TOKEN", csrf.token);
    // or set it in a cookie like so:
    //
    //     response.setCookie({
    //       name: "X-CSRF-TOKEN",
    //       value: csrf.token,
    //     });

    // No need to return anything here. Clients should make a GET request to
    // this resource to get the token (or cookie) and handle it appropriately.
  }

  public POST(request: Drash.Request, response: Drash.Response): void {
    const token = request.headers.get("X-CSRF-TOKEN");
    // or get the token from the cookie if it is set there
    //
    //     const token = request.getCookie("X-CSRF-TOKEN");

    if (token) {
      return response.text(token);
    }

    // No need to return a response or throw an error. Since we are protecting
    // this POST method using csrf, csrf will throw a 400 Bad Request
  }

  public DELETE(request: Drash.Request, response: Drash.Response): void {
    return response.text("Hello! You made a DELETE request.");
  }
}

// Create and run your server

const server = new Drash.Server({
  hostname: "0.0.0.0",
  port: 1447,
  protocol: "http",
  resources: [
    HomeResource
  ],
});

server.run();

console.log(`Server running at ${server.address}.`);
```

## Verification

1. Run your app.

  ```shell
  $ deno run --allow-net app.ts
  ```

2. Using `curl` (or similar command), make a `POST` request to `http://localhost:1447`.

  ```shell
  $ curl -v -X POST http://localhost:1447
  ```

  You should receive a response similar to the following:

  ```text
  *   Trying ::1...
  * TCP_NODELAY set
  * Connection failed
  * connect to ::1 port 1447 failed: Connection refused
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to localhost (127.0.0.1) port 1447 (#0)
  > POST / HTTP/1.1
  > Host: localhost:1447
  > User-Agent: curl/7.64.1
  > Accept: */*
  >
  < HTTP/1.1 400 Bad Request
  < content-type: text/plain;charset=UTF-8
  < content-length: 438
  < date: Tue, 19 Oct 2021 12:21:20 GMT
  <
  Error: No CSRF token was passed in
      at CSRFService.runBeforeResource (file:///services/csrf/csrf.ts:44:13)
      at runServices (file:///http/server.ts:49:35)
      at Server.<anonymous> (file:///http/server.ts:257:51)
  * Connection #0 to host localhost left intact
      at async Server.#respond (https://deno.land/std@0.111.0/http/server.ts:350:24)* Closing connection 0
  ```

  As you can see, the response is a `400 Bad Request` response and the response body contains `Error: NO CSRF token was passed in`. Since `CSRFService` is protecting the `POST` method, `POST` requests require the token generated by `CSRFService`.

3. Try to forge the token by passing in some random value.

  ```shell
  $ curl -v -X POST -H "x-csrf-token: f0rg3d" http://localhost:1447
  ```

  ```text
  *   Trying ::1...
  * TCP_NODELAY set
  * Connection failed
  * connect to ::1 port 1447 failed: Connection refused
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to localhost (127.0.0.1) port 1447 (#0)
  > POST / HTTP/1.1
  > Host: localhost:1447
  > User-Agent: curl/7.64.1
  > Accept: */*
  > x-csrf-token: f0rg3d
  >
  < HTTP/1.1 403 Forbidden
  < content-type: text/plain;charset=UTF-8
  < content-length: 439
  < date: Tue, 19 Oct 2021 12:40:31 GMT
  <
  Error: The CSRF tokens do not match
      at CSRFService.runBeforeResource (file:///services/csrf/csrf.ts:51:13)
      at runServices (file:///http/server.ts:49:35)
      at Server.<anonymous> (file:///http/server.ts:257:51)
  * Connection #0 to host localhost left intact
      at async Server.#respond (https://deno.land/std@0.111.0/http/server.ts:350:24)* Closing connection 0
  ```

  As you can see, the response is a `403 Forbidden` response and the response body contains `Error: The CSRF tokens do not match`. When `CSRFService` is instantiated, it generates a token and tokens from requests are checked against that generated token. Since the `f0rg3d` token does not match the `CSRFService` generated token, the `403` response is returned.

2. Now, get the the token using `curl` (or similar command) by making a `GET` request to `http://localhost:1447`.

  ```shell
  $ curl http://localhost:1447
  ```

  You should receive the following response:

  ```text
  *   Trying ::1...
  * TCP_NODELAY set
  * Connection failed
  * connect to ::1 port 1447 failed: Connection refused
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to localhost (127.0.0.1) port 1447 (#0)
  > GET / HTTP/1.1
  > Host: localhost:1447
  > User-Agent: curl/7.64.1
  > Accept: */*
  >
  < HTTP/1.1 200 OK
  < x-csrf-token: 3514e6083add270d13ad091870ce72402e8f2dc49c4ca91da6d40fd2b47425939580ce1e8e8200c3ed6b852ea59acd6fbc718ffe6b7cc8b73577f39424dc7ee5
  < content-length: 0
  < date: Tue, 19 Oct 2021 12:19:03 GMT
  <
  * Connection #0 to host localhost left intact
  * Closing connection 0
  ```

  As you can see, the `x-csrf-token` header containing the CSRF token generated by `CSRFService` is present.

3. Now that we have the token, we can make a `POST` request. So, copy the value of `x-csrf-token` and use it when making a `POST` request.

  _Note that YOUR `x-csrf-token` will be different from the one shown in this tutorial. So, please make sure you copy YOUR `x-csrf-token` and not the one in this tutorial. Also, this tutorial is using headers and not cookies, so the below command will set headers and not cookies to make the `POST` request._

  ```shell
  $ curl -v -X POST -H "x-csrf-token: 3514e6083add270d13ad091870ce72402e8f2dc49c4ca91da6d40fd2b47425939580ce1e8e8200c3ed6b852ea59acd6fbc718ffe6b7cc8b73577f39424dc7ee5" http://localhost:1447
  ```

  You should receive a response similar to the following:

  ```text
  *   Trying ::1...
  * TCP_NODELAY set
  * Connection failed
  * connect to ::1 port 1447 failed: Connection refused
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to localhost (127.0.0.1) port 1447 (#0)
  > POST / HTTP/1.1
  > Host: localhost:1447
  > User-Agent: curl/7.64.1
  > Accept: */*
  > X-CSRF-TOKEN: 3514e6083add270d13ad091870ce72402e8f2dc49c4ca91da6d40fd2b47425939580ce1e8e8200c3ed6b852ea59acd6fbc718ffe6b7cc8b73577f39424dc7ee5
  >
  < HTTP/1.1 200 OK
  < content-type: text/plain
  < content-length: 91
  < date: Tue, 19 Oct 2021 12:27:08 GMT
  <
  * Connection #0 to host localhost left intact
  Nice! Your POST request was received and processed because you passed in the correct token.* Closing connection 0
  ```

  As you can see, the response is a `200 OK` response. Since the correct token was passed in, the `POST` method was able to process the request.

4. To further exercise that all is working, try making a `DELETE` request without the token. The `DELETE` method in the resource is NOT protected by `CSRFService` so requests should not fail if a token is not present in the headers.

  ```shell
  $ curl -v -X DELETE http://localhost:1447
  ```

  You should receive a response similar to the following:

  ```text
  *   Trying ::1...
  * TCP_NODELAY set
  * Connection failed
  * connect to ::1 port 1447 failed: Connection refused
  *   Trying 127.0.0.1...
  * TCP_NODELAY set
  * Connected to localhost (127.0.0.1) port 1447 (#0)
  > DELETE / HTTP/1.1
  > Host: localhost:1447
  > User-Agent: curl/7.64.1
  > Accept: */*
  >
  < HTTP/1.1 200 OK
  < content-type: text/plain
  < content-length: 33
  < date: Tue, 19 Oct 2021 12:36:22 GMT
  <
  * Connection #0 to host localhost left intact
  Hello! You made a DELETE request.* Closing connection 0
  ```

  As you can see, the response is a `200 OK` response. Since the `DELETE` method is not protected, `DELETE` requests do not require the token.

## How It Works

`CSRFService` will generate a cryptographically secure token -- one that is made up from the following process:

1. Generate a UUID.
2. Generate a SHA512 hash.
3. Update the SHA512 hash with the UUID.

The result will look something like the following:

```text
44c9e0a4817ca0f7644947a01cde1cae8ae30cc233352ca23baea8ed0123ca07c2528973419da4ffc4ae4b9c2c95707042ee8346c2ff2de5844ab3d5380b2e62
```

If HTTP methods in a resource are protected by `CSRFService`, then `CSRFService` will check requests for the token and one of the following will happen:

* If the token is present and is valid, then the HTTP method processes the request
* If the token is present and is invalid (e.g., forged by a malicious client), then `CSRFService` will throw a `403` error.
* If the token is not present (in the headers or cookies), then `CSRFService` will throw a `400` error.
